<!DOCTYPE html>
<html lang="en-AU">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WH21SW75WP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-WH21SW75WP');
</script>

  <meta charset="UTF-8" />
  <title>Universal File Converter | NutriThrive Quick Tools</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Convert files between formats: Images (HEIC, PNG, JPG, GIF, WEBP, TIFF, SVG), Documents (PDF, DOC, DOCX, TXT, RTF, ODT, HTML), Audio (MP3, WAV, OGG, FLAC, M4A), Video (MP4, MOV, AVI, WMV, WEBM, MKV), Archives (ZIP, RAR, 7Z, TAR)." />
  <link rel="icon" type="image/png" href="https://i.imgur.com/bZubhoR.png">
  <link rel="apple-touch-icon" href="https://i.imgur.com/bZubhoR.png">
  <link rel="shortcut icon" href="https://i.imgur.com/bZubhoR.png">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary: #8AA624;
      --light: #DBE4C9;
      --bg: #FFFFF0;
      --accent: #FEA405;
      --text: #1a1a1a;
      --text-light: #666666;
      --border: #DBE4C9;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      margin: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 0;
      line-height: 1.6;
    }

    .app-container {
      max-width: 1000px;
      margin: 0 auto;
      padding: 60px 40px;
    }

    @media (max-width: 768px) {
      .app-container {
        padding: 40px 24px;
      }
    }

    .header {
      text-align: center;
      margin-bottom: 60px;
      padding-bottom: 40px;
      border-bottom: 2px solid var(--border);
    }

    .header h1 {
      font-size: 3rem;
      font-weight: 300;
      color: var(--text);
      margin-bottom: 16px;
      letter-spacing: -1px;
    }

    .header p {
      color: var(--text-light);
      font-size: 1.1rem;
      font-weight: 400;
      max-width: 600px;
      margin: 0 auto;
    }

    .converter-card {
      background: white;
      border: 2px solid var(--border);
      padding: 50px;
      margin-bottom: 40px;
    }

    @media (max-width: 768px) {
      .converter-card {
        padding: 32px 24px;
      }
    }

    .section-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-light);
      margin-bottom: 32px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .file-drop-zone {
      border: 2px solid var(--border);
      padding: 80px 40px;
      text-align: center;
      background: var(--bg);
      cursor: pointer;
      transition: border-color 0.2s;
      margin-bottom: 32px;
    }

    .file-drop-zone:hover {
      border-color: var(--primary);
    }

    .file-drop-zone.dragover {
      border-color: var(--primary);
      background: var(--light);
    }

    .file-drop-zone-icon {
      font-size: 4rem;
      margin-bottom: 20px;
      color: var(--primary);
      font-weight: 300;
      line-height: 1;
    }

    .file-drop-zone-text {
      font-size: 1.2rem;
      font-weight: 500;
      color: var(--text);
      margin-bottom: 8px;
      letter-spacing: -0.3px;
    }

    .file-drop-zone-hint {
      color: var(--text-light);
      font-size: 0.95rem;
      font-weight: 400;
    }

    .file-info {
      display: none;
      padding: 24px;
      background: var(--bg);
      margin-bottom: 32px;
      border: 2px solid var(--border);
    }

    .file-info.active {
      display: block;
    }

    .file-name {
      font-weight: 500;
      color: var(--text);
      margin-bottom: 6px;
      font-size: 1rem;
      letter-spacing: -0.2px;
    }

    .file-size {
      color: var(--text-light);
      font-size: 0.9rem;
      font-weight: 400;
    }

    .format-selector {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 32px;
      margin-bottom: 40px;
    }

    @media (max-width: 768px) {
      .format-selector {
        grid-template-columns: 1fr;
        gap: 24px;
      }
    }

    .format-group {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .format-label {
      font-weight: 500;
      color: var(--text);
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .format-select {
      padding: 16px 20px;
      border: 2px solid var(--border);
      background: white;
      color: var(--text);
      font-size: 1rem;
      font-weight: 400;
      cursor: pointer;
      transition: border-color 0.2s;
      font-family: inherit;
    }

    .format-select:focus {
      outline: none;
      border-color: var(--primary);
    }

    .convert-btn {
      width: 100%;
      padding: 20px 32px;
      background: var(--primary);
      color: white;
      border: none;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
      margin-bottom: 32px;
      text-transform: uppercase;
      letter-spacing: 1.5px;
    }

    .convert-btn:hover:not(:disabled) {
      background: var(--accent);
    }

    .convert-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      background: var(--border);
      color: var(--text-light);
    }

    .status-message {
      padding: 20px 24px;
      margin-bottom: 32px;
      font-weight: 400;
      display: none;
      border: 2px solid;
    }

    .status-message.active {
      display: block;
    }

    .status-success {
      background: var(--bg);
      color: var(--text);
      border-color: var(--primary);
    }

    .status-error {
      background: var(--bg);
      color: var(--text);
      border-color: var(--accent);
    }

    .status-info {
      background: var(--bg);
      color: var(--text);
      border-color: var(--border);
    }

    .download-section {
      display: none;
      padding: 32px;
      background: var(--bg);
      border: 2px solid var(--primary);
      text-align: center;
    }

    .download-section.active {
      display: block;
    }

    .download-section > div {
      font-weight: 500;
      color: var(--text);
      margin-bottom: 20px;
      font-size: 0.95rem;
      letter-spacing: 0.5px;
    }

    .download-btn {
      padding: 16px 40px;
      background: var(--primary);
      color: white;
      border: none;
      font-size: 0.95rem;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
      text-transform: uppercase;
      letter-spacing: 1.5px;
    }

    .download-btn:hover {
      background: var(--accent);
    }

    .format-categories {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 24px;
      margin-top: 40px;
    }

    .category-card {
      background: white;
      border: 2px solid var(--border);
      padding: 28px 24px;
    }

    .category-title {
      font-weight: 500;
      color: var(--text);
      margin-bottom: 16px;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .category-formats {
      font-size: 0.85rem;
      color: var(--text-light);
      line-height: 2;
      font-weight: 400;
    }

    .category-formats code {
      background: var(--bg);
      padding: 4px 8px;
      font-size: 0.8rem;
      font-weight: 500;
      color: var(--text);
      border: 1px solid var(--border);
    }

    input[type="file"] {
      display: none;
    }

    .preview-area {
      margin-top: 32px;
      padding: 24px;
      background: var(--bg);
      border: 2px solid var(--border);
      display: none;
    }

    .preview-area.active {
      display: block;
    }

    .preview-area img {
      max-width: 100%;
      height: auto;
    }

    .preview-area video {
      max-width: 100%;
    }

    .preview-area audio {
      width: 100%;
      margin-top: 12px;
    }

    footer {
      text-align: center;
      color: var(--text-light);
      font-size: 0.85rem;
      margin-top: 60px;
      padding-top: 40px;
      border-top: 2px solid var(--border);
      font-weight: 400;
    }
  </style>
  <script src="pdf.min.js"></script>
  <script src="pdf.worker.min.js" type="text/javascript"></script>
  <script src="jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html-docx-js@0.3.1/dist/html-docx.js" onerror="console.error('Failed to load html-docx-js')"></script>
  <script src="https://cdn.jsdelivr.net/npm/mammoth@1.6.0/mammoth.browser.min.js"></script>
  <script>
    // Wait for libraries to load and ensure html-docx-js is available
    window.addEventListener('load', function() {
      // Check multiple possible global names for html-docx-js
      if (typeof HTMLDocx === 'undefined' && typeof window !== 'undefined') {
        window.HTMLDocx = window.HTMLDocx || window.htmlDocx || window.htmlDocxJs || null;
      }
    });
  </script>
  <script>
    if (window.pdfjsLib) {
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'pdf.worker.min.js';
    }
  </script>
</head>
<body>
  <div class="app-container">
    <div class="header">
      <h1>Universal File Converter</h1>
      <p>Convert files between formats instantly. Images, Documents, Audio, Video, and Archivesâ€”all in your browser.</p>
        </div>

    <div class="converter-card">
      <div class="section-title">Upload File</div>
      
      <div class="file-drop-zone" id="dropZone">
        <div class="file-drop-zone-icon">+</div>
        <div class="file-drop-zone-text">Drop your file here or click to browse</div>
        <div class="file-drop-zone-hint">Supports all major file formats</div>
      </div>
      <input type="file" id="fileInput" accept="*/*" />

      <div class="file-info" id="fileInfo">
        <div class="file-name" id="fileName"></div>
        <div class="file-size" id="fileSize"></div>
        </div>

      <div class="preview-area" id="previewArea"></div>

      <div class="format-selector">
        <div class="format-group">
          <label class="format-label">From Format</label>
          <select class="format-select" id="fromFormat" disabled>
            <option value="">Select source format...</option>
          </select>
      </div>
        <div class="format-group">
          <label class="format-label">To Format</label>
          <select class="format-select" id="toFormat" disabled>
            <option value="">Select target format...</option>
          </select>
        </div>
      </div>

      <button class="convert-btn" id="convertBtn" disabled>Convert File</button>

      <div class="status-message" id="statusMessage"></div>

      <div class="download-section" id="downloadSection">
        <div>Conversion Complete</div>
        <button class="download-btn" id="downloadBtn">Download Converted File</button>
        </div>
      </div>

    <div class="converter-card">
      <div class="section-title">Supported Formats</div>
      <div class="format-categories">
        <div class="category-card">
          <div class="category-title">Images</div>
          <div class="category-formats">
            <code>HEIC</code> <code>PNG</code> <code>JPG</code> <code>GIF</code><br>
            <code>WEBP</code> <code>TIFF</code> <code>SVG</code>
        </div>
        </div>
        <div class="category-card">
          <div class="category-title">Documents</div>
          <div class="category-formats">
            <code>PDF</code> <code>DOC</code> <code>DOCX</code> <code>TXT</code><br>
            <code>RTF</code> <code>ODT</code> <code>HTML</code>
        </div>
        </div>
        <div class="category-card">
          <div class="category-title">Audio</div>
          <div class="category-formats">
            <code>MP3</code> <code>WAV</code> <code>OGG</code><br>
            <code>FLAC</code> <code>M4A</code>
        </div>
          </div>
        <div class="category-card">
          <div class="category-title">Video</div>
          <div class="category-formats">
            <code>MP4</code> <code>MOV</code> <code>AVI</code><br>
            <code>WMV</code> <code>WEBM</code> <code>MKV</code>
          </div>
        </div>
        <div class="category-card">
          <div class="category-title">Archives</div>
          <div class="category-formats">
            <code>ZIP</code> <code>RAR</code> <code>7Z</code> <code>TAR</code>
          </div>
        </div>
    </div>
      </div>

    <footer>
      All conversions happen locally in your browser. Your files never leave your device.
    </footer>
  </div>

  <script>
    const fileInput = document.getElementById('fileInput');
    const dropZone = document.getElementById('dropZone');
    const fileInfo = document.getElementById('fileInfo');
    const fileName = document.getElementById('fileName');
    const fileSize = document.getElementById('fileSize');
    const fromFormat = document.getElementById('fromFormat');
    const toFormat = document.getElementById('toFormat');
    const convertBtn = document.getElementById('convertBtn');
    const statusMessage = document.getElementById('statusMessage');
    const downloadSection = document.getElementById('downloadSection');
    const downloadBtn = document.getElementById('downloadBtn');
    const previewArea = document.getElementById('previewArea');

    let currentFile = null;
    let convertedBlob = null;

    // Format categories
    const formats = {
      images: ['HEIC', 'PNG', 'JPG', 'JPEG', 'GIF', 'WEBP', 'TIFF', 'SVG'],
      documents: ['PDF', 'DOC', 'DOCX', 'TXT', 'RTF', 'ODT', 'HTML'],
      audio: ['MP3', 'WAV', 'OGG', 'FLAC', 'M4A'],
      video: ['MP4', 'MOV', 'AVI', 'WMV', 'WEBM', 'MKV'],
      archives: ['ZIP', 'RAR', '7Z', 'TAR']
    };

    // All formats combined
    const allFormats = [...formats.images, ...formats.documents, ...formats.audio, ...formats.video, ...formats.archives];

    // Get file extension
    function getFileExtension(filename) {
      return filename.split('.').pop().toUpperCase();
    }

    // Format file size
    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
    }

    // Show status
    function showStatus(message, type = 'info') {
      statusMessage.textContent = message;
      statusMessage.className = `status-message active status-${type}`;
      setTimeout(() => {
        statusMessage.classList.remove('active');
      }, 5000);
    }

    // Handle file selection
    function handleFile(file) {
      if (!file) return;

      currentFile = file;
      const ext = getFileExtension(file.name);
      
      fileName.textContent = file.name;
      fileSize.textContent = formatFileSize(file.size);
      fileInfo.classList.add('active');
      downloadSection.classList.remove('active');
      previewArea.classList.remove('active');
      convertedBlob = null;

      // Populate from format
      fromFormat.innerHTML = '<option value="">Select source format...</option>';
      if (allFormats.includes(ext)) {
        const option = document.createElement('option');
        option.value = ext;
        option.textContent = ext;
        option.selected = true;
        fromFormat.appendChild(option);
      } else {
        const option = document.createElement('option');
        option.value = ext;
        option.textContent = ext + ' (detected)';
        option.selected = true;
        fromFormat.appendChild(option);
      }

      // Populate to format based on category
      toFormat.innerHTML = '<option value="">Select target format...</option>';
      let targetFormats = [];
      
      if (formats.images.includes(ext)) {
        targetFormats = formats.images.filter(f => f !== ext);
      } else if (formats.documents.includes(ext)) {
        targetFormats = formats.documents.filter(f => f !== ext);
      } else if (formats.audio.includes(ext)) {
        targetFormats = formats.audio.filter(f => f !== ext);
      } else if (formats.video.includes(ext)) {
        targetFormats = formats.video.filter(f => f !== ext);
      } else if (formats.archives.includes(ext)) {
        targetFormats = formats.archives.filter(f => f !== ext);
      } else {
        // Unknown format - show all formats
        targetFormats = allFormats.filter(f => f !== ext);
      }

      targetFormats.forEach(format => {
        const option = document.createElement('option');
        option.value = format;
        option.textContent = format;
        toFormat.appendChild(option);
      });

      fromFormat.disabled = false;
      toFormat.disabled = false;
      convertBtn.disabled = !toFormat.value;

      // Show preview
      if (file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = (e) => {
          previewArea.innerHTML = `<img src="${e.target.result}" alt="Preview" />`;
          previewArea.classList.add('active');
        };
        reader.readAsDataURL(file);
      } else if (file.type.startsWith('video/')) {
        const reader = new FileReader();
        reader.onload = (e) => {
          previewArea.innerHTML = `<video controls src="${e.target.result}"></video>`;
          previewArea.classList.add('active');
        };
        reader.readAsDataURL(file);
      } else if (file.type.startsWith('audio/')) {
        const reader = new FileReader();
        reader.onload = (e) => {
          previewArea.innerHTML = `<audio controls src="${e.target.result}"></audio>`;
          previewArea.classList.add('active');
        };
        reader.readAsDataURL(file);
      }
    }

    // File input handlers
    dropZone.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => {
      if (e.target.files.length) handleFile(e.target.files[0]);
    });

    // Drag and drop
    ['dragenter', 'dragover'].forEach(evt => {
      dropZone.addEventListener(evt, (e) => {
      e.preventDefault();
      e.stopPropagation();
      dropZone.classList.add('dragover');
      });
    });

    ['dragleave', 'drop'].forEach(evt => {
      dropZone.addEventListener(evt, (e) => {
      e.preventDefault();
      e.stopPropagation();
      dropZone.classList.remove('dragover');
      });
    });

    dropZone.addEventListener('drop', (e) => {
      const file = e.dataTransfer.files[0];
      if (file) handleFile(file);
    });

    // Format change handlers
    toFormat.addEventListener('change', () => {
      convertBtn.disabled = !toFormat.value || !fromFormat.value;
    });

    fromFormat.addEventListener('change', () => {
      convertBtn.disabled = !toFormat.value || !fromFormat.value;
    });

    // Convert function
    convertBtn.addEventListener('click', async () => {
      if (!currentFile || !fromFormat.value || !toFormat.value) return;

        convertBtn.disabled = true;
      showStatus('Converting...', 'info');

      try {
        const fromExt = fromFormat.value.toLowerCase();
        const toExt = toFormat.value.toLowerCase();
        
        convertedBlob = await convertFile(currentFile, fromExt, toExt);
        
        if (convertedBlob) {
          downloadSection.classList.add('active');
          showStatus('Conversion successful!', 'success');
        } else {
          showStatus('Conversion not supported for this format combination.', 'error');
        }
      } catch (error) {
        console.error('Conversion error:', error);
        showStatus('Conversion failed: ' + error.message, 'error');
      } finally {
      convertBtn.disabled = false;
      }
    });

    // Download handler
    downloadBtn.addEventListener('click', () => {
      if (!convertedBlob) return;
      
      const url = URL.createObjectURL(convertedBlob);
      const a = document.createElement('a');
      a.href = url;
      const originalName = currentFile.name.replace(/\.[^/.]+$/, '');
      a.download = `${originalName}.${toFormat.value.toLowerCase()}`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    // Conversion functions
    async function convertFile(file, fromExt, toExt) {
      // Image conversions
      if (formats.images.map(f => f.toLowerCase()).includes(fromExt) && 
          formats.images.map(f => f.toLowerCase()).includes(toExt)) {
        return await convertImage(file, toExt);
      }

      // PDF conversions (check before general document conversions)
      if (fromExt === 'pdf') {
        if (toExt === 'txt') {
          return await pdfToText(file);
        }
        if (toExt === 'html') {
          return await pdfToHtml(file);
        }
        if (toExt === 'rtf') {
          // PDF to RTF via text extraction
          const textBlob = await pdfToText(file);
          const text = await textBlob.text();
          const rtf = `{\\rtf1\\ansi\\deff0 {\\fonttbl {\\f0 Times New Roman;}}\\f0\\fs24 ${text.replace(/\n/g, '\\par ').replace(/[{}]/g, '')}}`;
          return new Blob([rtf], { type: 'application/rtf' });
        }
        if (toExt === 'docx') {
          return await pdfToDocx(file);
        }
        // PDF to Image conversions
        if (formats.images.map(f => f.toLowerCase()).includes(toExt)) {
          return await pdfToImage(file, toExt);
        }
        // DOC, ODT require server-side processing
        if (['doc', 'odt'].includes(toExt)) {
          throw new Error(`${toExt.toUpperCase()} conversion requires server-side processing. Try converting to DOCX, TXT or HTML first.`);
        }
      }

      // Text to PDF
      if (fromExt === 'txt' && toExt === 'pdf') {
        return await textToPdf(file);
      }

      // DOCX conversions
      if (fromExt === 'docx') {
        if (toExt === 'pdf') {
          return await docxToPdf(file);
        }
        if (toExt === 'txt') {
          return await docxToText(file);
        }
        if (toExt === 'html') {
          return await docxToHtml(file);
        }
        if (toExt === 'rtf') {
          return await docxToRtf(file);
        }
        if (toExt === 'doc') {
          throw new Error('DOCX to DOC conversion requires server-side processing. Try converting to PDF or HTML instead.');
        }
        if (toExt === 'odt') {
          throw new Error('DOCX to ODT conversion requires server-side processing. Try converting to PDF or HTML instead.');
        }
      }

      // HTML conversions
      if (fromExt === 'html') {
        if (toExt === 'pdf') {
          return await htmlToPdf(file);
        }
        if (toExt === 'txt') {
          const html = await file.text();
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = html;
          const text = tempDiv.innerText || tempDiv.textContent || '';
          return new Blob([text], { type: 'text/plain' });
        }
      }

      // Document conversions (non-PDF, non-DOCX)
      if (formats.documents.map(f => f.toLowerCase()).includes(fromExt) && 
          formats.documents.map(f => f.toLowerCase()).includes(toExt)) {
        return await convertDocument(file, fromExt, toExt);
      }

      // Archive conversions
      if (formats.archives.map(f => f.toLowerCase()).includes(fromExt) && 
          formats.archives.map(f => f.toLowerCase()).includes(toExt)) {
        return await convertArchive(file, fromExt, toExt);
      }

      // Video conversions
      if (formats.video.map(f => f.toLowerCase()).includes(fromExt) && 
          formats.video.map(f => f.toLowerCase()).includes(toExt)) {
        return await convertVideo(file, fromExt, toExt);
      }

      // Audio conversions
      if (formats.audio.map(f => f.toLowerCase()).includes(fromExt) && 
          formats.audio.map(f => f.toLowerCase()).includes(toExt)) {
        return await convertAudio(file, fromExt, toExt);
      }

      showStatus('Conversion between ' + fromExt + ' and ' + toExt + ' is not yet supported.', 'error');
      return null;
    }

    // Image conversion
    async function convertImage(file, targetFormat) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            
            canvas.toBlob((blob) => {
              resolve(blob);
            }, `image/${targetFormat === 'jpg' ? 'jpeg' : targetFormat}`, 0.95);
          };
          img.onerror = reject;
          img.src = e.target.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    // PDF to Text
    async function pdfToText(file) {
      if (!window.pdfjsLib) throw new Error('PDF library not loaded');
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      let text = '';
      for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
        const page = await pdf.getPage(pageNum);
        const content = await page.getTextContent();
        const pageText = content.items.map(item => item.str).join(' ');
        text += pageText + '\n\n';
      }
      return new Blob([text], { type: 'text/plain' });
    }

    // PDF to HTML
    async function pdfToHtml(file) {
      if (!window.pdfjsLib) throw new Error('PDF library not loaded');
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      let html = '<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Converted PDF</title></head><body>';
      for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
        const page = await pdf.getPage(pageNum);
        const content = await page.getTextContent();
        html += '<div style="page-break-after:always;padding:20px;">';
        content.items.forEach(item => {
          html += `<p>${item.str}</p>`;
        });
        html += '</div>';
      }
      html += '</body></html>';
      return new Blob([html], { type: 'text/html' });
    }

    // PDF to Image
    async function pdfToImage(file, targetFormat) {
      if (!window.pdfjsLib) throw new Error('PDF library not loaded');
      
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      
      // For multi-page PDFs, combine all pages into one tall image
      const scale = 2; // Higher quality
      const pages = [];
      let totalHeight = 0;
      let maxWidth = 0;
      
      // Render all pages first to get dimensions
      for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
        const page = await pdf.getPage(pageNum);
        const viewport = page.getViewport({ scale });
        maxWidth = Math.max(maxWidth, viewport.width);
        totalHeight += viewport.height;
        pages.push({ page, viewport, height: viewport.height });
      }
      
      // Create combined canvas
      const canvas = document.createElement('canvas');
      canvas.width = maxWidth;
      canvas.height = totalHeight;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Render all pages onto the canvas
      let currentY = 0;
      for (const { page, viewport } of pages) {
        const renderContext = {
          canvasContext: ctx,
          viewport: viewport
        };
        await page.render(renderContext).promise;
        currentY += viewport.height;
        ctx.translate(0, viewport.height);
      }
      
      // Convert canvas to blob in target format
      return new Promise((resolve, reject) => {
        const mimeType = targetFormat === 'jpg' || targetFormat === 'jpeg' 
          ? 'image/jpeg' 
          : `image/${targetFormat}`;
        
        canvas.toBlob((blob) => {
          if (blob) {
            resolve(blob);
          } else {
            reject(new Error('Failed to convert PDF page to image'));
          }
        }, mimeType, 0.95);
      });
    }

    // PDF to DOCX
    async function pdfToDocx(file) {
      const htmlDocxLib = await getHtmlDocxLib();
      
      const textBlob = await pdfToText(file);
      const text = await textBlob.text();
      
      // Convert text to HTML first
      const html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><style>body{font-family:Arial,sans-serif;line-height:1.6;padding:20px;max-width:800px;margin:0 auto;}p{margin:12px 0;white-space:pre-wrap;}</style></head><body>${text.split(/\n\s*\n/).map(p => `<p>${p.replace(/\n/g, '<br>').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p>`).join('')}</body></html>`;
      
      // Use the library to convert HTML to DOCX
      const converted = htmlDocxLib.asBlob(html);
      return converted;
    }

    // Helper function to get html-docx-js library
    async function getHtmlDocxLib() {
      let htmlDocxLib = window.HTMLDocx || window.htmlDocx || window.htmlDocxJs || (typeof HTMLDocx !== 'undefined' ? HTMLDocx : null);
      
      if (!htmlDocxLib || typeof htmlDocxLib.asBlob !== 'function') {
        // Try loading from unpkg as fallback
        if (!window.htmlDocxLoaded) {
          await new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/html-docx-js@0.3.1/dist/html-docx.js';
            script.onload = () => {
              window.htmlDocxLoaded = true;
              resolve();
            };
            script.onerror = () => {
              console.error('Failed to load html-docx-js from fallback CDN');
              resolve(); // Don't reject, just continue
            };
            document.head.appendChild(script);
          });
        }
        
        htmlDocxLib = window.HTMLDocx || window.htmlDocx || window.htmlDocxJs;
        if (!htmlDocxLib || typeof htmlDocxLib.asBlob !== 'function') {
          throw new Error('DOCX library failed to load. Please check your internet connection and reload the page.');
        }
      }
      
      return htmlDocxLib;
    }

    // Text to DOCX
    async function textToDocx(file) {
      const htmlDocxLib = await getHtmlDocxLib();
      const text = await file.text();
      // Convert text to HTML first, then to DOCX
      const html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><style>body{font-family:Arial,sans-serif;line-height:1.6;padding:20px;max-width:800px;margin:0 auto;}p{margin:12px 0;white-space:pre-wrap;}</style></head><body>${text.split(/\n\s*\n/).map(p => `<p>${p.replace(/\n/g, '<br>').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p>`).join('')}</body></html>`;
      return await htmlToDocx(new Blob([html], { type: 'text/html' }));
    }

    // HTML to DOCX
    async function htmlToDocx(file) {
      const htmlDocxLib = await getHtmlDocxLib();
      const html = await file.text();
      const converted = htmlDocxLib.asBlob(html);
      return converted;
    }

    // DOCX to Text
    async function docxToText(file) {
      if (typeof mammoth === 'undefined') {
        throw new Error('DOCX reader library not loaded. Please reload the page.');
      }
      const arrayBuffer = await file.arrayBuffer();
      const result = await mammoth.extractRawText({ arrayBuffer });
      return new Blob([result.value], { type: 'text/plain' });
    }

    // DOCX to HTML
    async function docxToHtml(file) {
      if (typeof mammoth === 'undefined') {
        throw new Error('DOCX reader library not loaded. Please reload the page.');
      }
      const arrayBuffer = await file.arrayBuffer();
      const result = await mammoth.convertToHtml({ arrayBuffer });
      return new Blob([result.value], { type: 'text/html' });
    }

    // DOCX to PDF
    async function docxToPdf(file) {
      if (typeof mammoth === 'undefined' || !window.jspdf) {
        throw new Error('Required libraries not loaded. Please reload the page.');
      }
      // Convert DOCX to text first, then to PDF
      const textBlob = await docxToText(file);
      return await textToPdf(textBlob);
    }

    // DOCX to RTF
    async function docxToRtf(file) {
      if (typeof mammoth === 'undefined') {
        throw new Error('DOCX reader library not loaded. Please reload the page.');
      }
      // Convert DOCX to text first, then to RTF
      const textBlob = await docxToText(file);
      const text = await textBlob.text();
      const rtf = `{\\rtf1\\ansi\\deff0 {\\fonttbl {\\f0 Times New Roman;}}\\f0\\fs24 ${text.replace(/\n/g, '\\par ').replace(/[{}]/g, '')}}`;
      return new Blob([rtf], { type: 'application/rtf' });
    }

    // Text to PDF
    async function textToPdf(file) {
      if (!window.jspdf || !window.jspdf.jsPDF) throw new Error('PDF generator not loaded');
      const text = await file.text();
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({ unit: 'pt', format: 'a4' });
        const margin = 48;
        const width = doc.internal.pageSize.getWidth() - margin * 2;
        const lines = doc.splitTextToSize(text, width);
      doc.setFont('Helvetica', 'Normal');
        doc.setFontSize(12);
      let y = margin + 12;
      for (let i = 0; i < lines.length; i++) {
        if (y > doc.internal.pageSize.getHeight() - margin) {
          doc.addPage();
          y = margin;
        }
        doc.text(lines[i], margin, y);
        y += 14;
      }
      return doc.output('blob');
    }

    // HTML to PDF
    async function htmlToPdf(file) {
      if (!window.jspdf || !window.jspdf.jsPDF) throw new Error('PDF generator not loaded');
      const html = await file.text();
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = html;
      const text = tempDiv.innerText || tempDiv.textContent || '';
      return await textToPdf(new Blob([text], { type: 'text/plain' }));
    }

    // Document conversion (simplified - mainly text extraction)
    async function convertDocument(file, fromExt, toExt) {
      // TXT conversions
      if (toExt === 'txt') {
        // For text-based formats, try to read as text
        try {
          const text = await file.text();
          return new Blob([text], { type: 'text/plain' });
        } catch (e) {
          throw new Error('Could not extract text from this file format.');
        }
      }
      
      // TXT to other formats
      if (fromExt === 'txt') {
        if (toExt === 'pdf') {
          return await textToPdf(file);
        }
        if (toExt === 'html') {
          const text = await file.text();
          const html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Converted Text</title><style>body{font-family:sans-serif;line-height:1.6;max-width:800px;margin:40px auto;padding:20px;}</style></head><body><pre style="white-space:pre-wrap;word-wrap:break-word;">${text.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre></body></html>`;
          return new Blob([html], { type: 'text/html' });
        }
        if (toExt === 'rtf') {
          const text = await file.text();
          const rtf = `{\\rtf1\\ansi\\deff0 {\\fonttbl {\\f0 Times New Roman;}}\\f0\\fs24 ${text.replace(/\n/g, '\\par ')}}`;
          return new Blob([rtf], { type: 'application/rtf' });
        }
      }

      // RTF conversions
      if (fromExt === 'rtf' && toExt === 'txt') {
        const rtf = await file.text();
        // Simple RTF to text extraction (removes RTF codes)
        const text = rtf.replace(/\{[^}]*\}/g, '').replace(/\\[a-z]+\d*\s?/gi, '').replace(/\\par/g, '\n').trim();
        return new Blob([text], { type: 'text/plain' });
      }

      // TXT to DOCX
      if (fromExt === 'txt' && toExt === 'docx') {
        return await textToDocx(file);
      }

      // HTML to DOCX
      if (fromExt === 'html' && toExt === 'docx') {
        return await htmlToDocx(file);
      }

      // DOC, ODT reading requires special libraries
      if (['doc', 'odt'].includes(fromExt)) {
        throw new Error(`Reading ${fromExt.toUpperCase()} files requires server-side processing. Please convert your file to DOCX, TXT or HTML first, then convert to your desired format.`);
      }

      // DOC, ODT writing requires server-side processing
      if (['doc', 'odt'].includes(toExt)) {
        throw new Error(`${toExt.toUpperCase()} conversion requires server-side processing. Try converting to DOCX, TXT or HTML instead.`);
      }

      throw new Error(`Conversion from ${fromExt.toUpperCase()} to ${toExt.toUpperCase()} is not supported. Try converting to TXT or HTML as an intermediate format.`);
    }

    // Archive conversion
    async function convertArchive(file, fromExt, toExt) {
      if (!window.JSZip) throw new Error('Archive library not loaded');
      
      if (fromExt === 'zip' && toExt === 'zip') {
        // Re-zip (just return original)
        return file;
      }

      if (fromExt === 'zip') {
        if (toExt === 'rar' || toExt === '7z') {
          // ZIP to RAR/7Z requires server-side processing
          throw new Error(`${toExt.toUpperCase()} conversion requires server-side processing. ZIP files can be opened by most archive tools.`);
        }
        
        if (toExt === 'tar') {
          // Convert ZIP to TAR (simplified - just re-zip)
          showStatus('TAR conversion requires additional library. ZIP format maintained.', 'info');
          return file;
        }
      }

      // RAR/7Z to ZIP requires extraction libraries
      if (['rar', '7z'].includes(fromExt)) {
        throw new Error(`${fromExt.toUpperCase()} extraction requires server-side processing. Please extract the file first, then create a new ZIP archive.`);
      }

      throw new Error(`Archive conversion from ${fromExt.toUpperCase()} to ${toExt.toUpperCase()} is not supported.`);
    }

    // Video conversion
    async function convertVideo(file, fromExt, toExt) {
      return new Promise((resolve, reject) => {
        const video = document.createElement('video');
        video.preload = 'metadata';
        video.muted = true;
        video.playsInline = true;
        
        const url = URL.createObjectURL(file);
        video.src = url;

        video.onloadedmetadata = () => {
          video.currentTime = 0.1; // Seek to ensure video is loaded
        };

        video.oncanplay = () => {
          const canvas = document.createElement('canvas');
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          const ctx = canvas.getContext('2d');

          // Determine MIME type based on target format
          let mimeType = 'video/webm';
          let codecs = 'vp8';
          
          if (toExt === 'webm') {
            mimeType = 'video/webm';
            codecs = 'vp8';
          } else if (toExt === 'mp4') {
            mimeType = 'video/mp4';
            codecs = 'avc1.42E01E';
          } else if (toExt === 'mov') {
            mimeType = 'video/quicktime';
            codecs = 'avc1.42E01E';
          } else if (toExt === 'avi') {
            mimeType = 'video/x-msvideo';
            codecs = 'avc1.42E01E';
          } else if (toExt === 'wmv') {
            mimeType = 'video/x-ms-wmv';
            codecs = 'wmv3';
          } else if (toExt === 'mkv') {
            mimeType = 'video/x-matroska';
            codecs = 'vp8';
          }

          // Check if MediaRecorder supports the format
          if (!MediaRecorder.isTypeSupported(mimeType)) {
            // Fallback to webm if format not supported
            mimeType = 'video/webm';
            codecs = 'vp8';
            if (!MediaRecorder.isTypeSupported(mimeType)) {
              URL.revokeObjectURL(url);
              reject(new Error('Video conversion not supported in this browser. Try Chrome or Firefox.'));
              return;
            }
          }

          const chunks = [];
          const stream = canvas.captureStream(30); // 30 FPS
          const recorder = new MediaRecorder(stream, {
            mimeType: mimeType,
            videoBitsPerSecond: 2500000 // 2.5 Mbps
          });

          recorder.ondataavailable = (e) => {
            if (e.data.size > 0) {
              chunks.push(e.data);
            }
          };

          recorder.onstop = () => {
            const blob = new Blob(chunks, { type: mimeType });
            URL.revokeObjectURL(url);
            resolve(blob);
          };

          recorder.onerror = (e) => {
            URL.revokeObjectURL(url);
            reject(new Error('Recording error: ' + e.error));
          };

          // Draw video frames to canvas and record
          let recording = false;
          const drawFrame = () => {
            if (video.ended || video.paused) {
              if (recording) {
                recorder.stop();
              }
        return;
      }

            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            if (!recording && video.currentTime > 0) {
              recording = true;
              recorder.start();
            }

            requestAnimationFrame(drawFrame);
          };

          video.onplay = () => {
            drawFrame();
          };

          // Start playback
          video.play().catch(err => {
            URL.revokeObjectURL(url);
            reject(new Error('Could not play video: ' + err.message));
          });

          // Stop after video ends
          video.onended = () => {
            if (recording) {
              recorder.stop();
            }
          };

          // Safety timeout
          setTimeout(() => {
            if (recording) {
              recorder.stop();
            }
          }, (video.duration || 60) * 1000 + 5000);
        };

        video.onerror = () => {
          URL.revokeObjectURL(url);
          reject(new Error('Could not load video file'));
        };
      });
    }

    // Audio conversion
    async function convertAudio(file, fromExt, toExt) {
      return new Promise((resolve, reject) => {
        const audio = document.createElement('audio');
        audio.preload = 'auto';
        
        const url = URL.createObjectURL(file);
        audio.src = url;

        audio.oncanplaythrough = () => {
          // Determine MIME type based on target format
          let mimeType = 'audio/webm';
          
          if (toExt === 'webm' || toExt === 'ogg') {
            mimeType = 'audio/webm';
          } else if (toExt === 'mp3') {
            mimeType = 'audio/mpeg';
          } else if (toExt === 'wav') {
            mimeType = 'audio/wav';
          } else if (toExt === 'm4a') {
            mimeType = 'audio/mp4';
          } else if (toExt === 'flac') {
            mimeType = 'audio/flac';
          }

          // Check if MediaRecorder supports the format
          if (!MediaRecorder.isTypeSupported(mimeType)) {
            // Fallback to webm
            mimeType = 'audio/webm';
            if (!MediaRecorder.isTypeSupported(mimeType)) {
              URL.revokeObjectURL(url);
              reject(new Error('Audio conversion not supported in this browser. Try Chrome or Firefox.'));
        return;
      }
          }

          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioContext.createMediaElementSource(audio);
          const destination = audioContext.createMediaStreamDestination();
          source.connect(destination);
          source.connect(audioContext.destination);

          const chunks = [];
          const recorder = new MediaRecorder(destination.stream, {
            mimeType: mimeType,
            audioBitsPerSecond: 128000 // 128 kbps
          });

          recorder.ondataavailable = (e) => {
            if (e.data.size > 0) {
              chunks.push(e.data);
            }
          };

          recorder.onstop = () => {
            const blob = new Blob(chunks, { type: mimeType });
            audioContext.close();
            URL.revokeObjectURL(url);
            resolve(blob);
          };

          recorder.onerror = (e) => {
            audioContext.close();
            URL.revokeObjectURL(url);
            reject(new Error('Recording error: ' + e.error));
          };

          audio.onplay = () => {
            recorder.start();
          };

          audio.onended = () => {
            recorder.stop();
          };

          // Start playback
          audio.play().catch(err => {
            audioContext.close();
            URL.revokeObjectURL(url);
            reject(new Error('Could not play audio: ' + err.message));
          });

          // Safety timeout
          setTimeout(() => {
            if (recorder.state === 'recording') {
              recorder.stop();
            }
          }, (audio.duration || 60) * 1000 + 5000);
        };

        audio.onerror = () => {
          URL.revokeObjectURL(url);
          reject(new Error('Could not load audio file'));
        };
      });
    }
  </script>
</body>
</html>

