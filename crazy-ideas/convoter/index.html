<!DOCTYPE html>
<html lang="en-AU">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WH21SW75WP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-WH21SW75WP');
</script>

  <meta charset="UTF-8" />
  <title>Universal File Converter | NutriThrive Quick Tools</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Convert files between formats: Images (HEIC, PNG, JPG, GIF, WEBP, TIFF, SVG), Documents (PDF, DOC, DOCX, TXT, RTF, ODT, HTML), Audio (MP3, WAV, OGG, FLAC, M4A), Video (MP4, MOV, AVI, WMV, WEBM, MKV), Archives (ZIP, RAR, 7Z, TAR)." />
  <link rel="icon" type="image/png" href="https://i.imgur.com/bZubhoR.png">
  <link rel="apple-touch-icon" href="https://i.imgur.com/bZubhoR.png">
  <link rel="shortcut icon" href="https://i.imgur.com/bZubhoR.png">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #b7e2c3;
      --surface: #ffffff;
      --surface-alt: #eef6f1;
      --accent: #38677a;
      --accent-light: #5f8b9d;
      --ink: #0f2530;
      --muted: #4c646c;
      --border: #86a8b5;
      --success: #10b981;
      --warning: #f59e0b;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      margin: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg);
      color: var(--ink);
      min-height: 100vh;
      padding: 24px;
    }

    .app-container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .header {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 40px;
      margin-bottom: 32px;
      text-align: center;
    }

    .header h1 {
      font-size: 2.5rem;
      font-weight: 800;
      color: var(--accent);
      margin-bottom: 12px;
      letter-spacing: -0.5px;
    }

    .header p {
      color: var(--muted);
      font-size: 1.1rem;
      line-height: 1.6;
    }

    .converter-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 40px;
      margin-bottom: 24px;
    }

    .section-title {
      font-size: 1.3rem;
      font-weight: 700;
      color: var(--accent);
      margin-bottom: 24px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .file-drop-zone {
      border: 2px dashed var(--border);
      border-radius: 16px;
      padding: 60px 40px;
      text-align: center;
      background: var(--surface-alt);
      cursor: pointer;
      transition: all 0.3s;
      margin-bottom: 24px;
    }

    .file-drop-zone:hover {
      border-color: var(--accent);
      background: var(--surface);
    }

    .file-drop-zone.dragover {
      border-color: var(--accent);
      background: var(--surface);
      transform: scale(1.02);
    }

    .file-drop-zone-icon {
      font-size: 4rem;
      margin-bottom: 16px;
    }

    .file-drop-zone-text {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--ink);
      margin-bottom: 8px;
    }

    .file-drop-zone-hint {
      color: var(--muted);
      font-size: 0.95rem;
    }

    .file-info {
      display: none;
      padding: 20px;
      background: var(--surface-alt);
      border-radius: 12px;
      margin-bottom: 24px;
      border: 1px solid var(--border);
    }

    .file-info.active {
      display: block;
    }

    .file-name {
      font-weight: 700;
      color: var(--accent);
      margin-bottom: 8px;
      font-size: 1.1rem;
    }

    .file-size {
      color: var(--muted);
      font-size: 0.9rem;
    }

    .format-selector {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      margin-bottom: 32px;
    }

    @media (max-width: 768px) {
      .format-selector {
        grid-template-columns: 1fr;
      }
    }

    .format-group {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .format-label {
      font-weight: 600;
      color: var(--ink);
      font-size: 0.95rem;
    }

    .format-select {
      padding: 14px 16px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--surface);
      color: var(--ink);
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .format-select:focus {
      outline: none;
      border-color: var(--accent);
    }

    .convert-btn {
      width: 100%;
      padding: 18px 32px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 12px;
      font-size: 1.1rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s;
      margin-bottom: 24px;
    }

    .convert-btn:hover:not(:disabled) {
      opacity: 0.9;
      transform: translateY(-2px);
    }

    .convert-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .status-message {
      padding: 16px;
      border-radius: 12px;
      margin-bottom: 24px;
      font-weight: 500;
      display: none;
    }

    .status-message.active {
      display: block;
    }

    .status-success {
      background: #d1fae5;
      color: #065f46;
      border: 1px solid #10b981;
    }

    .status-error {
      background: #fee2e2;
      color: #991b1b;
      border: 1px solid #ef4444;
    }

    .status-info {
      background: #dbeafe;
      color: #1e40af;
      border: 1px solid #3b82f6;
    }

    .download-section {
      display: none;
      padding: 24px;
      background: var(--surface-alt);
      border-radius: 12px;
      border: 1px solid var(--border);
      text-align: center;
    }

    .download-section.active {
      display: block;
    }

    .download-btn {
      padding: 14px 28px;
      background: var(--success);
      color: white;
      border: none;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
    }

    .download-btn:hover {
      opacity: 0.9;
    }

    .format-categories {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-top: 32px;
    }

    .category-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
    }

    .category-title {
      font-weight: 700;
      color: var(--accent);
      margin-bottom: 12px;
      font-size: 1rem;
    }

    .category-formats {
      font-size: 0.9rem;
      color: var(--muted);
      line-height: 1.8;
    }

    .category-formats code {
      background: var(--surface-alt);
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.85rem;
    }

    input[type="file"] {
      display: none;
    }

    .preview-area {
      margin-top: 24px;
      padding: 20px;
      background: var(--surface-alt);
      border-radius: 12px;
      border: 1px solid var(--border);
      display: none;
    }

    .preview-area.active {
      display: block;
    }

    .preview-area img {
      max-width: 100%;
      height: auto;
      border-radius: 8px;
    }

    .preview-area video {
      max-width: 100%;
      border-radius: 8px;
    }

    .preview-area audio {
      width: 100%;
      margin-top: 12px;
    }

    footer {
      text-align: center;
      color: var(--muted);
      font-size: 0.9rem;
      margin-top: 40px;
      padding: 24px;
    }
  </style>
  <script src="pdf.min.js"></script>
  <script src="pdf.worker.min.js" type="text/javascript"></script>
  <script src="jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script>
    if (window.pdfjsLib) {
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'pdf.worker.min.js';
    }
  </script>
</head>
<body>
  <div class="app-container">
    <div class="header">
      <h1>üîÑ Universal File Converter</h1>
      <p>Convert files between formats instantly. Images, Documents, Audio, Video, and Archives‚Äîall in your browser.</p>
        </div>

    <div class="converter-card">
      <div class="section-title">üìÅ Upload File</div>
      
      <div class="file-drop-zone" id="dropZone">
        <div class="file-drop-zone-icon">üìé</div>
        <div class="file-drop-zone-text">Drop your file here or click to browse</div>
        <div class="file-drop-zone-hint">Supports all major file formats</div>
      </div>
      <input type="file" id="fileInput" accept="*/*" />

      <div class="file-info" id="fileInfo">
        <div class="file-name" id="fileName"></div>
        <div class="file-size" id="fileSize"></div>
      </div>

      <div class="preview-area" id="previewArea"></div>

      <div class="format-selector">
        <div class="format-group">
          <label class="format-label">From Format</label>
          <select class="format-select" id="fromFormat" disabled>
            <option value="">Select source format...</option>
          </select>
        </div>
        <div class="format-group">
          <label class="format-label">To Format</label>
          <select class="format-select" id="toFormat" disabled>
            <option value="">Select target format...</option>
          </select>
        </div>
      </div>

      <button class="convert-btn" id="convertBtn" disabled>üîÑ Convert File</button>

      <div class="status-message" id="statusMessage"></div>

      <div class="download-section" id="downloadSection">
        <div style="font-weight:600;margin-bottom:16px;color:var(--accent);">‚úì Conversion Complete!</div>
        <button class="download-btn" id="downloadBtn">‚¨áÔ∏è Download Converted File</button>
      </div>
        </div>

    <div class="converter-card">
      <div class="section-title">üìã Supported Formats</div>
      <div class="format-categories">
        <div class="category-card">
          <div class="category-title">üñºÔ∏è Images</div>
          <div class="category-formats">
            <code>HEIC</code> <code>PNG</code> <code>JPG</code> <code>GIF</code><br>
            <code>WEBP</code> <code>TIFF</code> <code>SVG</code>
        </div>
        </div>
        <div class="category-card">
          <div class="category-title">üìÑ Documents</div>
          <div class="category-formats">
            <code>PDF</code> <code>DOC</code> <code>DOCX</code> <code>TXT</code><br>
            <code>RTF</code> <code>ODT</code> <code>HTML</code>
        </div>
        </div>
        <div class="category-card">
          <div class="category-title">üéµ Audio</div>
          <div class="category-formats">
            <code>MP3</code> <code>WAV</code> <code>OGG</code><br>
            <code>FLAC</code> <code>M4A</code>
          </div>
        </div>
        <div class="category-card">
          <div class="category-title">üé¨ Video</div>
          <div class="category-formats">
            <code>MP4</code> <code>MOV</code> <code>AVI</code><br>
            <code>WMV</code> <code>WEBM</code> <code>MKV</code>
          </div>
        </div>
        <div class="category-card">
          <div class="category-title">üì¶ Archives</div>
          <div class="category-formats">
            <code>ZIP</code> <code>RAR</code> <code>7Z</code> <code>TAR</code>
          </div>
        </div>
      </div>
      </div>

    <footer>
      All conversions happen locally in your browser. Your files never leave your device.
    </footer>
  </div>

  <script>
    const fileInput = document.getElementById('fileInput');
    const dropZone = document.getElementById('dropZone');
    const fileInfo = document.getElementById('fileInfo');
    const fileName = document.getElementById('fileName');
    const fileSize = document.getElementById('fileSize');
    const fromFormat = document.getElementById('fromFormat');
    const toFormat = document.getElementById('toFormat');
    const convertBtn = document.getElementById('convertBtn');
    const statusMessage = document.getElementById('statusMessage');
    const downloadSection = document.getElementById('downloadSection');
    const downloadBtn = document.getElementById('downloadBtn');
    const previewArea = document.getElementById('previewArea');

    let currentFile = null;
    let convertedBlob = null;

    // Format categories
    const formats = {
      images: ['HEIC', 'PNG', 'JPG', 'JPEG', 'GIF', 'WEBP', 'TIFF', 'SVG'],
      documents: ['PDF', 'DOC', 'DOCX', 'TXT', 'RTF', 'ODT', 'HTML'],
      audio: ['MP3', 'WAV', 'OGG', 'FLAC', 'M4A'],
      video: ['MP4', 'MOV', 'AVI', 'WMV', 'WEBM', 'MKV'],
      archives: ['ZIP', 'RAR', '7Z', 'TAR']
    };

    // All formats combined
    const allFormats = [...formats.images, ...formats.documents, ...formats.audio, ...formats.video, ...formats.archives];

    // Get file extension
    function getFileExtension(filename) {
      return filename.split('.').pop().toUpperCase();
    }

    // Format file size
    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
    }

    // Show status
    function showStatus(message, type = 'info') {
      statusMessage.textContent = message;
      statusMessage.className = `status-message active status-${type}`;
      setTimeout(() => {
        statusMessage.classList.remove('active');
      }, 5000);
    }

    // Handle file selection
    function handleFile(file) {
      if (!file) return;

      currentFile = file;
      const ext = getFileExtension(file.name);
      
      fileName.textContent = file.name;
      fileSize.textContent = formatFileSize(file.size);
      fileInfo.classList.add('active');
      downloadSection.classList.remove('active');
      previewArea.classList.remove('active');
      convertedBlob = null;

      // Populate from format
      fromFormat.innerHTML = '<option value="">Select source format...</option>';
      if (allFormats.includes(ext)) {
        const option = document.createElement('option');
        option.value = ext;
        option.textContent = ext;
        option.selected = true;
        fromFormat.appendChild(option);
      } else {
        const option = document.createElement('option');
        option.value = ext;
        option.textContent = ext + ' (detected)';
        option.selected = true;
        fromFormat.appendChild(option);
      }

      // Populate to format based on category
      toFormat.innerHTML = '<option value="">Select target format...</option>';
      let targetFormats = [];
      
      if (formats.images.includes(ext)) {
        targetFormats = formats.images.filter(f => f !== ext);
      } else if (formats.documents.includes(ext)) {
        targetFormats = formats.documents.filter(f => f !== ext);
      } else if (formats.audio.includes(ext)) {
        targetFormats = formats.audio.filter(f => f !== ext);
      } else if (formats.video.includes(ext)) {
        targetFormats = formats.video.filter(f => f !== ext);
      } else if (formats.archives.includes(ext)) {
        targetFormats = formats.archives.filter(f => f !== ext);
      } else {
        // Unknown format - show all formats
        targetFormats = allFormats.filter(f => f !== ext);
      }

      targetFormats.forEach(format => {
        const option = document.createElement('option');
        option.value = format;
        option.textContent = format;
        toFormat.appendChild(option);
      });

      fromFormat.disabled = false;
      toFormat.disabled = false;
      convertBtn.disabled = !toFormat.value;

      // Show preview
      if (file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = (e) => {
          previewArea.innerHTML = `<img src="${e.target.result}" alt="Preview" />`;
          previewArea.classList.add('active');
        };
        reader.readAsDataURL(file);
      } else if (file.type.startsWith('video/')) {
        const reader = new FileReader();
        reader.onload = (e) => {
          previewArea.innerHTML = `<video controls src="${e.target.result}"></video>`;
          previewArea.classList.add('active');
        };
        reader.readAsDataURL(file);
      } else if (file.type.startsWith('audio/')) {
        const reader = new FileReader();
        reader.onload = (e) => {
          previewArea.innerHTML = `<audio controls src="${e.target.result}"></audio>`;
          previewArea.classList.add('active');
        };
        reader.readAsDataURL(file);
      }
    }

    // File input handlers
    dropZone.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => {
      if (e.target.files.length) handleFile(e.target.files[0]);
    });

    // Drag and drop
    ['dragenter', 'dragover'].forEach(evt => {
      dropZone.addEventListener(evt, (e) => {
      e.preventDefault();
      e.stopPropagation();
      dropZone.classList.add('dragover');
      });
    });

    ['dragleave', 'drop'].forEach(evt => {
      dropZone.addEventListener(evt, (e) => {
      e.preventDefault();
      e.stopPropagation();
      dropZone.classList.remove('dragover');
      });
    });

    dropZone.addEventListener('drop', (e) => {
      const file = e.dataTransfer.files[0];
      if (file) handleFile(file);
    });

    // Format change handlers
    toFormat.addEventListener('change', () => {
      convertBtn.disabled = !toFormat.value || !fromFormat.value;
    });

    fromFormat.addEventListener('change', () => {
      convertBtn.disabled = !toFormat.value || !fromFormat.value;
    });

    // Convert function
    convertBtn.addEventListener('click', async () => {
      if (!currentFile || !fromFormat.value || !toFormat.value) return;

      convertBtn.disabled = true;
      showStatus('Converting...', 'info');

      try {
        const fromExt = fromFormat.value.toLowerCase();
        const toExt = toFormat.value.toLowerCase();
        
        convertedBlob = await convertFile(currentFile, fromExt, toExt);
        
        if (convertedBlob) {
          downloadSection.classList.add('active');
          showStatus('Conversion successful!', 'success');
        } else {
          showStatus('Conversion not supported for this format combination.', 'error');
        }
      } catch (error) {
        console.error('Conversion error:', error);
        showStatus('Conversion failed: ' + error.message, 'error');
      } finally {
        convertBtn.disabled = false;
      }
    });

    // Download handler
    downloadBtn.addEventListener('click', () => {
      if (!convertedBlob) return;
      
      const url = URL.createObjectURL(convertedBlob);
      const a = document.createElement('a');
      a.href = url;
      const originalName = currentFile.name.replace(/\.[^/.]+$/, '');
      a.download = `${originalName}.${toFormat.value.toLowerCase()}`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    // Conversion functions
    async function convertFile(file, fromExt, toExt) {
      // Image conversions
      if (formats.images.map(f => f.toLowerCase()).includes(fromExt) && 
          formats.images.map(f => f.toLowerCase()).includes(toExt)) {
        return await convertImage(file, toExt);
      }

      // Document conversions
      if (formats.documents.map(f => f.toLowerCase()).includes(fromExt) && 
          formats.documents.map(f => f.toLowerCase()).includes(toExt)) {
        return await convertDocument(file, fromExt, toExt);
      }

      // PDF to other formats
      if (fromExt === 'pdf') {
        if (toExt === 'txt') {
          return await pdfToText(file);
        }
        if (toExt === 'html') {
          return await pdfToHtml(file);
        }
      }

      // Text to PDF
      if (fromExt === 'txt' && toExt === 'pdf') {
        return await textToPdf(file);
      }

      // HTML to PDF
      if (fromExt === 'html' && toExt === 'pdf') {
        return await htmlToPdf(file);
      }

      // Archive conversions
      if (formats.archives.map(f => f.toLowerCase()).includes(fromExt) && 
          formats.archives.map(f => f.toLowerCase()).includes(toExt)) {
        return await convertArchive(file, fromExt, toExt);
      }

      // Video conversions
      if (formats.video.map(f => f.toLowerCase()).includes(fromExt) && 
          formats.video.map(f => f.toLowerCase()).includes(toExt)) {
        return await convertVideo(file, fromExt, toExt);
      }

      // Audio conversions
      if (formats.audio.map(f => f.toLowerCase()).includes(fromExt) && 
          formats.audio.map(f => f.toLowerCase()).includes(toExt)) {
        return await convertAudio(file, fromExt, toExt);
      }

      showStatus('Conversion between ' + fromExt + ' and ' + toExt + ' is not yet supported.', 'error');
      return null;
    }

    // Image conversion
    async function convertImage(file, targetFormat) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            
            canvas.toBlob((blob) => {
              resolve(blob);
            }, `image/${targetFormat === 'jpg' ? 'jpeg' : targetFormat}`, 0.95);
          };
          img.onerror = reject;
          img.src = e.target.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    // PDF to Text
    async function pdfToText(file) {
      if (!window.pdfjsLib) throw new Error('PDF library not loaded');
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      let text = '';
      for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
        const page = await pdf.getPage(pageNum);
        const content = await page.getTextContent();
        const pageText = content.items.map(item => item.str).join(' ');
        text += pageText + '\n\n';
      }
      return new Blob([text], { type: 'text/plain' });
    }

    // PDF to HTML
    async function pdfToHtml(file) {
      if (!window.pdfjsLib) throw new Error('PDF library not loaded');
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      let html = '<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Converted PDF</title></head><body>';
      for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
        const page = await pdf.getPage(pageNum);
        const content = await page.getTextContent();
        html += '<div style="page-break-after:always;padding:20px;">';
        content.items.forEach(item => {
          html += `<p>${item.str}</p>`;
        });
        html += '</div>';
      }
      html += '</body></html>';
      return new Blob([html], { type: 'text/html' });
    }

    // Text to PDF
    async function textToPdf(file) {
      if (!window.jspdf || !window.jspdf.jsPDF) throw new Error('PDF generator not loaded');
      const text = await file.text();
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({ unit: 'pt', format: 'a4' });
        const margin = 48;
        const width = doc.internal.pageSize.getWidth() - margin * 2;
        const lines = doc.splitTextToSize(text, width);
      doc.setFont('Helvetica', 'Normal');
        doc.setFontSize(12);
      let y = margin + 12;
      for (let i = 0; i < lines.length; i++) {
        if (y > doc.internal.pageSize.getHeight() - margin) {
          doc.addPage();
          y = margin;
        }
        doc.text(lines[i], margin, y);
        y += 14;
      }
      return doc.output('blob');
    }

    // HTML to PDF
    async function htmlToPdf(file) {
      if (!window.jspdf || !window.jspdf.jsPDF) throw new Error('PDF generator not loaded');
      const html = await file.text();
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = html;
      const text = tempDiv.innerText || tempDiv.textContent || '';
      return await textToPdf(new Blob([text], { type: 'text/plain' }));
    }

    // Document conversion (simplified - mainly text extraction)
    async function convertDocument(file, fromExt, toExt) {
      if (toExt === 'txt') {
        if (fromExt === 'pdf') {
          return await pdfToText(file);
        }
        // For other formats, try to read as text
        const text = await file.text();
        return new Blob([text], { type: 'text/plain' });
      }
      
      if (fromExt === 'txt' && toExt === 'pdf') {
        return await textToPdf(file);
      }

      if (fromExt === 'txt' && toExt === 'html') {
        const text = await file.text();
        const html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Converted Text</title></head><body><pre>${text}</pre></body></html>`;
        return new Blob([html], { type: 'text/html' });
      }

      if (fromExt === 'html' && toExt === 'txt') {
        const html = await file.text();
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = html;
        const text = tempDiv.innerText || tempDiv.textContent || '';
        return new Blob([text], { type: 'text/plain' });
      }

      throw new Error('Document conversion not supported');
    }

    // Archive conversion
    async function convertArchive(file, fromExt, toExt) {
      if (!window.JSZip) throw new Error('Archive library not loaded');
      
      if (fromExt === 'zip' && toExt === 'zip') {
        // Re-zip (just return original)
        return file;
      }

      if (fromExt === 'zip') {
        const zip = await JSZip.loadAsync(file);
        const files = [];
        zip.forEach((relativePath, file) => {
          files.push({ name: relativePath, data: file });
        });
        
        if (toExt === 'tar') {
          // Convert to TAR format (simplified)
          showStatus('TAR conversion requires additional library. ZIP format maintained.', 'info');
          return file;
        }
      }

      throw new Error('Archive conversion not fully supported');
    }

    // Video conversion
    async function convertVideo(file, fromExt, toExt) {
      return new Promise((resolve, reject) => {
        const video = document.createElement('video');
        video.preload = 'metadata';
        video.muted = true;
        video.playsInline = true;
        
        const url = URL.createObjectURL(file);
        video.src = url;

        video.onloadedmetadata = () => {
          video.currentTime = 0.1; // Seek to ensure video is loaded
        };

        video.oncanplay = () => {
          const canvas = document.createElement('canvas');
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          const ctx = canvas.getContext('2d');

          // Determine MIME type based on target format
          let mimeType = 'video/webm';
          let codecs = 'vp8';
          
          if (toExt === 'webm') {
            mimeType = 'video/webm';
            codecs = 'vp8';
          } else if (toExt === 'mp4') {
            mimeType = 'video/mp4';
            codecs = 'avc1.42E01E';
          } else if (toExt === 'mov') {
            mimeType = 'video/quicktime';
            codecs = 'avc1.42E01E';
          } else if (toExt === 'avi') {
            mimeType = 'video/x-msvideo';
            codecs = 'avc1.42E01E';
          } else if (toExt === 'wmv') {
            mimeType = 'video/x-ms-wmv';
            codecs = 'wmv3';
          } else if (toExt === 'mkv') {
            mimeType = 'video/x-matroska';
            codecs = 'vp8';
          }

          // Check if MediaRecorder supports the format
          if (!MediaRecorder.isTypeSupported(mimeType)) {
            // Fallback to webm if format not supported
            mimeType = 'video/webm';
            codecs = 'vp8';
            if (!MediaRecorder.isTypeSupported(mimeType)) {
              URL.revokeObjectURL(url);
              reject(new Error('Video conversion not supported in this browser. Try Chrome or Firefox.'));
              return;
            }
          }

          const chunks = [];
          const stream = canvas.captureStream(30); // 30 FPS
          const recorder = new MediaRecorder(stream, {
            mimeType: mimeType,
            videoBitsPerSecond: 2500000 // 2.5 Mbps
          });

          recorder.ondataavailable = (e) => {
            if (e.data.size > 0) {
              chunks.push(e.data);
            }
          };

          recorder.onstop = () => {
            const blob = new Blob(chunks, { type: mimeType });
            URL.revokeObjectURL(url);
            resolve(blob);
          };

          recorder.onerror = (e) => {
            URL.revokeObjectURL(url);
            reject(new Error('Recording error: ' + e.error));
          };

          // Draw video frames to canvas and record
          let recording = false;
          const drawFrame = () => {
            if (video.ended || video.paused) {
              if (recording) {
                recorder.stop();
              }
              return;
            }

            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            if (!recording && video.currentTime > 0) {
              recording = true;
              recorder.start();
            }

            requestAnimationFrame(drawFrame);
          };

          video.onplay = () => {
            drawFrame();
          };

          // Start playback
          video.play().catch(err => {
            URL.revokeObjectURL(url);
            reject(new Error('Could not play video: ' + err.message));
          });

          // Stop after video ends
          video.onended = () => {
            if (recording) {
              recorder.stop();
            }
          };

          // Safety timeout
          setTimeout(() => {
            if (recording) {
              recorder.stop();
            }
          }, (video.duration || 60) * 1000 + 5000);
        };

        video.onerror = () => {
          URL.revokeObjectURL(url);
          reject(new Error('Could not load video file'));
        };
      });
    }

    // Audio conversion
    async function convertAudio(file, fromExt, toExt) {
      return new Promise((resolve, reject) => {
        const audio = document.createElement('audio');
        audio.preload = 'auto';
        
        const url = URL.createObjectURL(file);
        audio.src = url;

        audio.oncanplaythrough = () => {
          // Determine MIME type based on target format
          let mimeType = 'audio/webm';
          
          if (toExt === 'webm' || toExt === 'ogg') {
            mimeType = 'audio/webm';
          } else if (toExt === 'mp3') {
            mimeType = 'audio/mpeg';
          } else if (toExt === 'wav') {
            mimeType = 'audio/wav';
          } else if (toExt === 'm4a') {
            mimeType = 'audio/mp4';
          } else if (toExt === 'flac') {
            mimeType = 'audio/flac';
          }

          // Check if MediaRecorder supports the format
          if (!MediaRecorder.isTypeSupported(mimeType)) {
            // Fallback to webm
            mimeType = 'audio/webm';
            if (!MediaRecorder.isTypeSupported(mimeType)) {
              URL.revokeObjectURL(url);
              reject(new Error('Audio conversion not supported in this browser. Try Chrome or Firefox.'));
              return;
            }
          }

          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioContext.createMediaElementSource(audio);
          const destination = audioContext.createMediaStreamDestination();
          source.connect(destination);
          source.connect(audioContext.destination);

          const chunks = [];
          const recorder = new MediaRecorder(destination.stream, {
            mimeType: mimeType,
            audioBitsPerSecond: 128000 // 128 kbps
          });

          recorder.ondataavailable = (e) => {
            if (e.data.size > 0) {
              chunks.push(e.data);
            }
          };

          recorder.onstop = () => {
            const blob = new Blob(chunks, { type: mimeType });
            audioContext.close();
            URL.revokeObjectURL(url);
            resolve(blob);
          };

          recorder.onerror = (e) => {
            audioContext.close();
            URL.revokeObjectURL(url);
            reject(new Error('Recording error: ' + e.error));
          };

          audio.onplay = () => {
            recorder.start();
          };

          audio.onended = () => {
            recorder.stop();
          };

          // Start playback
          audio.play().catch(err => {
            audioContext.close();
            URL.revokeObjectURL(url);
            reject(new Error('Could not play audio: ' + err.message));
          });

          // Safety timeout
          setTimeout(() => {
            if (recorder.state === 'recording') {
              recorder.stop();
            }
          }, (audio.duration || 60) * 1000 + 5000);
        };

        audio.onerror = () => {
          URL.revokeObjectURL(url);
          reject(new Error('Could not load audio file'));
        };
      });
    }
  </script>
</body>
</html>
